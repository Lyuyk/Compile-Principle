# Compile-Principle-Project



# Task 3 MiniC Language Test

   Test with mini-c lexicon and test with at least one mini-c source program for lexical analysis (this mini-c source program needs to be written by yourself based on mini-c lexicon and grammar, similar to sample.tny). Test with the mini-c grammar and carry out a grammar analysis with the word code file generated by testing the source program from the previous step, generating the corresponding grammar tree.

​      以 mini-c 的词法进行测试，并以至少一个 mini-c 源程序进行词法分析的测试（该mini-c 源程序需要自己根据 mini-c 词法和语法编写出来，类似于 sample.tny）。以 mini-c 的语法进行测试，并以测试上一步骤的源程序所生成的单词编码文件进行语法分析，生成对应的语法树。



## 项目实现

### 测试MiniC词法

#### 正则表达式

```
(_|\letter\)(_|\letter\|\digit\)*|\digit\+(.\digit\+)?|_|\+\|-|\*\|/|%|<|<=|>|>=|==|!=|=|;|,|\(\|\)\|[|]|{|}|//~*\`\n\
else|if|int|float|return|void|do|while
```

#### 词法分析测试示例用例（不保证完全正确）

```miniC
//Sample program
//In MiniC language-computes factorial
//}
int x = 2; // an integer
int fact = 2;
if ( x > 1 )  //don't compute if x <= 0 
    do 
        fact = fact * x;
        x = x - 1;
    while x >= 1;
return fact; //return 2^x

```

### 测试MiniC语法

#### 文法

```
program->definition-list
definition-list->definition-list definition | definition
definition->variable-definition | function-definition
variable-definition->type-indicator ID ;|type-indicator ID [ NUM ] ;
type-indicator->int | float | void
function-definition-> type-indicator ID ( parameters ) compound-stmt
parameters->parameter-list | void
parameter-list->parameter-list, parameter | parameter
parameter-> type-indicator ID | type-indicator ID [ ]
compound-stmt-> { local-definitions statement-list }
local-definitions-> local-definitions variable-definition |empty
statement-list-> statement-list statement | empty
statement->expression-stmt | compound-stmt | condition-stmt |dowhile-stmt | return-stmt
expression-stmt-> expression ; | ;
condition-stmt-> if ( expression ) statement|if ( expression ) statement else statement
dowhile-stmt->do statement while ( expression ) ;
return-stmt->return ;| return expression ;
expression-> variable = expression | simple-expression
variable->ID |ID [ expression ]
simple-expression->additive-expression relop additive-expression|additive-expression
relop-><=|<|>|>=|==|!=
additive-expression->additive-expression addop term | term
addop->+|-
term->term mulop factor | factor
mulop->*|/|%
factor->( expression )| variable | call | NUM
call->ID ( arguments )
arguments->argument-list | empty
argument-list->argument-list , expression | expression

```

#### 语法分析测试示例用例（不保证完全正确）

```
Keyword:void ID:func ( Keyword:void ) 
{
Keyword:int ID:x [ Digit:2 ] ; 
Keyword:int ID:fact [ Digit:2 ] ; 
Keyword:if ( ID:x > Digit:1 ) Keyword:do 
ID:fact = ID:fact * ID:x ; 
ID:x = ID:x - Digit:1 
Keyword:while ( ID:x >= Digit:1 ) ; 
Keyword:return ID:fact ; 
}


```

