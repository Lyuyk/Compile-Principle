# Compile-Principle-Course



# Task 2 (TINY’s) BNF Grammar Problem Processor

   The system requires an interface that allows the user to open a text file of all the BNF grammars of a language, simplify the grammar, eliminate the left common factor and left recursion, solve the First set and Follow set for each non-terminal symbol, and construct the LL(1) analysis table and present the results of all steps in a window. The LL(1) syntax analysis method is used to carry out the syntax analysis and generate the corresponding syntax tree, the structure of which can be defined for each statement as required. (The syntax tree needs to be presented in a tree-like form).

​      以文本文件的方式输入某一高级程序设计语言的所有语法对应的 BNF 文法，因此系统需要提供一个操作界面，让用户打开某一语言的所有语法对应的 BNF 文法的文本文件，依次化简文法、消除左公共因子以及左递归、求解每一个非终结符号的First集合和Follow集合，并构造出LL（1）分析表，并将所有步骤的结果用窗口展示。采用 LL(1)语法分析方法进行语法分析并生成相应的语法树，每个语句的语法树结构可根据实际的需要进行定义。 （语法树需要采用树状形式进行呈现）。



## 项目设计

### 功能结构图

```mermaid
flowchart LR
w[文法问题处理器]-->s(输入输出)-->从文件中读取文法
w-->化简文法
w-->提取左公因子
w-->消除左递归
w-->求First集和Follow集
w-->ss("生成LL(1)分析表")-->语法分析
```



## 项目实现

### 文法的存储

​      由于该项目的中会用到大量的根据规则左部非终结符寻找对应右部的操作，所以这个操作的时间复杂度应该尽可能小，于是将文法的存储结构设计为QMap<QString, QList<QString>>，即终结符→[右部1,右部2,...]的形式，这样通过一个哈希表存储左部和右部的映射关系，使得通过左部查询右部的平均时间复杂度达到$O(1)$。同时，为了方便后续的操作，还应该设计两个集合，分别存储所有的左部和所有出现过的非终结符。这样就能不遍历所有语法快速拿到所有左部，并且方便地生成一个没出现过的非终结符。当然，文法的开始符号也要拿一个char类型变量存下来。本项目中默认输入的第一个规则的左部的符号为文法的开始符号对于输入的处理首先要将输入中每行前后的空白去掉，并且输入中的空格也应该清除,方便处理的时候下标的计算。处理完空白和空格之后，首先应该存储左部，将左部存储到左部集合里和非终结符里即可。截取掉左部一个字符加中间的->一共3个字符后剩下的子串就是右部，对于右部则要干两件事，根据|分割右部，并且还要将右部出现的非终结符加入到非终结符集合中去。右部在根据|分割之后就可以一条条进行grammars[左部].push_back(右部),完成存储。

步骤图解：

```mermaid
flowchart LR
s(每一条文法)-->清除前后空格-->f["根据 |、->分割字符串"]-->存储文法及其它必要信息
```



### 文法化简

​      化简文法需要化简掉两种文法，有害文法U->U和多余规则(不可到达、不可终止)。

#### 有害文法的清除

​      在处理多余规则的时候就可以顺带清除。

#### 多余规则的清除

首先明确三个操作：1.搜索的具体操作就是遍历以当前字符为左部的所有规则，如果搜索到某个规则时，发现该规则右部全都是终结符，则说明该规则可以终止，搜索回溯时应该返回当前规则是否可终止。2.判断右部是否全是终结符，应该对右部的终结符进行计数，并于右部的总字符数进行比较。3.对于一个规则的右部而言，如果一个非终结符是可终止的，它也应该被当作一个终结符来看待，即对右部终结符进行计数时应该将可终止的非终结符也加上。接下来是整个算法的执行流程，首先开出两个集合reach和term，分别记录搜索到达的文法和可终止的文法。并且，注意reach和term还可以帮助搜索进行记忆化优化，即如果某个非终结符已经知道它可终结或已经到达过，就不需要再进去搜索了，相当于将搜索变为记忆化搜索，避免了重复计算并优化了递归深度。初始化完这两个集合后，就可以从文法的开始符号，开始进行搜索，注意此时要将开始符号加入到reach中,搜索完毕后还要根据返回值判断文法的开始符号是否加入term中，就对所有文法进行遍历，消除其中存在不在reach或term集合中的非终结符的规则。在遍历时顺便检查是否存在U->U的有害规则，进行消除。



### 消除左递归

左递归包括直接左递归和间接左递归，消除间接左递归中会用到消除直接左递归的操作，所以先思考消除直接左递归的实现。直接左递归的消除根据ppt上的算法进行即可，即A->Aα|β 变为 A->βA'和A'->αA'|ε,这主要是一些字符串的操作，主要考验编码能力，不涉及思路，不再赘述。对于间接左递归，我们需要进行代入来消除，但是代入时要注意，应该是之前已经处理干净的非终结符，才能放心地交给后面进行代入，代入完成后，调用消除直接左递归的算法即可。最后，还应该注意一点，我们在消除左递归的时候，会进行代入，这对于代入后能进行消除左递归的规则当然没问题，但是，对于代入后不能消除的规则就不太好了。虽然代入后它们其实还是一样的规则，但是这些规则的显示就不能保持用户输入的样子了，这其实是不太好的一件事情，虽然说这个程序也许没有用户会使用，不用去考虑用户体验，但是即便仅仅是对于我们自己debug来说，如果规则较为复杂，这个代入就会让debug的难度增加，因为有些并没有被消除左递归的规则变了样子，而这还需要我们观察才能发现它们变样只是因为进行了代入。所以，应该在代入之前存下规则的原样和一开始就有的左部。并设置消除直接左递归的函数返回是否有消除，这样，对于代入后未进行消除左递归，并且左部的是一开始就有的的规则，我们将它还原代入，将它们变回带入前的样子。



### 提取左公因子

对于左公因子的提取，有间接的左公因子和直接的左公因子两种。消除间接左公因子时要用到提取左公因子，所以先对直接左公因子进行提取。对于直接左公因子的提取，我们遍历所有文法，寻找左部相同的规则的右部的相同前缀，之后进行提取。在这里相同前缀的查找和一些经典的字符串算法有些不同，体现在 ①不需要所有右部都有公共前缀，其中有两个以上的右部有公共前缀就可以进行提取 ②许多经典算法一般是寻找最长公共前缀，但这里，为了算法更加简洁，每次提取的公共前缀不需要是最长的。

### 计算First集与Follow集



### 构造LL(1)分析表



### 分析语法（根据LL(1)语法分析方法）



